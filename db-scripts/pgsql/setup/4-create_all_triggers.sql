-- Generated by Ora2Pg, the Oracle database Schema converter, version 24.0
-- Copyright 2000-2023 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=10.145.9.179;sid=odevdbp01;port=1521

SET client_encoding TO 'UTF8';

-- \set ON_ERROR_STOP ON

DROP TRIGGER IF EXISTS active_tim_holding_trigger ON active_tim_holding CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_active_tim_holding_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('active_tim_holding_seq')
  INTO STRICT   NEW.ACTIVE_TIM_HOLDING_ID
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_active_tim_holding_trigger() FROM PUBLIC;

CREATE TRIGGER active_tim_holding_trigger
	BEFORE INSERT ON active_tim_holding FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_active_tim_holding_trigger();

DROP TRIGGER IF EXISTS active_tim_trigger ON active_tim CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_active_tim_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('active_tim_seq')
  INTO STRICT   NEW.active_tim_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_active_tim_trigger() FROM PUBLIC;

CREATE TRIGGER active_tim_trigger
	BEFORE INSERT ON active_tim FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_active_tim_trigger();

-- DROP TRIGGER IF EXISTS bsm_part2_spve_trigger ON bsm_part2_spve CASCADE; -- SKIPPING BSM-RELATED TRIGGERS
-- CREATE OR REPLACE FUNCTION trigger_fct_bsm_part2_spve_trigger() RETURNS trigger AS $BODY$
-- BEGIN
--   SELECT nextval('bsm_part2_spve_seq')
--   INTO STRICT   NEW.BSM_PART2_SPVE_ID
-- ;
-- RETURN NEW;
-- END
-- $BODY$
--  LANGUAGE 'plpgsql' SECURITY DEFINER;
-- -- REVOKE ALL ON FUNCTION trigger_fct_bsm_part2_spve_trigger() FROM PUBLIC;

-- CREATE TRIGGER bsm_part2_spve_trigger  -- SKIPPING BSM-RELATED TRIGGERS
-- 	BEFORE INSERT ON bsm_part2_spve FOR EACH ROW
-- 	EXECUTE PROCEDURE trigger_fct_bsm_part2_spve_trigger();

DROP TRIGGER IF EXISTS driver_alert_itis_code_trigger ON driver_alert_itis_code CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_driver_alert_itis_code_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('driver_alert_itis_code_seq')
  INTO STRICT   NEW.driver_alert_itis_code_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_driver_alert_itis_code_trigger() FROM PUBLIC;

CREATE TRIGGER driver_alert_itis_code_trigger
	BEFORE INSERT ON driver_alert_itis_code FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_driver_alert_itis_code_trigger();

DROP TRIGGER IF EXISTS driver_alert_trigger ON driver_alert CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_driver_alert_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('driver_alert_seq')
  INTO STRICT   NEW.driver_alert_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_driver_alert_trigger() FROM PUBLIC;

CREATE TRIGGER driver_alert_trigger
	BEFORE INSERT ON driver_alert FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_driver_alert_trigger();

DROP TRIGGER IF EXISTS driver_alert_type_trigger ON driver_alert_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_driver_alert_type_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('driver_alert_type_seq')
  INTO STRICT   NEW.driver_alert_type_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_driver_alert_type_trigger() FROM PUBLIC;

CREATE TRIGGER driver_alert_type_trigger
	BEFORE INSERT ON driver_alert_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_driver_alert_type_trigger();

DROP TRIGGER IF EXISTS hmi_log_trigger ON hmi_log CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_hmi_log_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('hmi_log_seq')
  INTO STRICT   NEW.hmi_log_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_hmi_log_trigger() FROM PUBLIC;

CREATE TRIGGER hmi_log_trigger
	BEFORE INSERT ON hmi_log FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_hmi_log_trigger();

DROP TRIGGER IF EXISTS incident_action_lut_trigger ON incident_action_lut CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_incident_action_lut_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('incident_action_lut_seq')
  INTO STRICT   NEW.incident_action_lut_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_incident_action_lut_trigger() FROM PUBLIC;

CREATE TRIGGER incident_action_lut_trigger
	BEFORE INSERT ON incident_action_lut FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_incident_action_lut_trigger();

DROP TRIGGER IF EXISTS incident_effect_lut_trigger ON incident_effect_lut CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_incident_effect_lut_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('incident_effect_lut_seq')
  INTO STRICT   NEW.incident_effect_lut_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_incident_effect_lut_trigger() FROM PUBLIC;

CREATE TRIGGER incident_effect_lut_trigger
	BEFORE INSERT ON incident_effect_lut FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_incident_effect_lut_trigger();

DROP TRIGGER IF EXISTS incident_problem_lut_trigger ON incident_problem_lut CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_incident_problem_lut_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('incident_problem_lut_seq')
  INTO STRICT   NEW.incident_problem_lut_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_incident_problem_lut_trigger() FROM PUBLIC;

CREATE TRIGGER incident_problem_lut_trigger
	BEFORE INSERT ON incident_problem_lut FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_incident_problem_lut_trigger();

DROP TRIGGER IF EXISTS notifications_trg ON notifications CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_notifications_trg() RETURNS trigger AS $BODY$
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF TG_OP = 'INSERT' AND NEW.LOG_ID IS NULL THEN
      SELECT nextval('notifications_seq') INTO STRICT NEW.LOG_ID;
    END IF;
  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_notifications_trg() FROM PUBLIC;

CREATE TRIGGER notifications_trg
	BEFORE INSERT ON notifications FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_notifications_trg();

DROP TRIGGER IF EXISTS obu_firmware_trg ON obu_firmware CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obu_firmware_trg() RETURNS trigger AS $BODY$
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF TG_OP = 'INSERT' AND NEW.FIRMWARE_ID IS NULL THEN
      SELECT nextval('obu_firmware_seq') INTO STRICT NEW.FIRMWARE_ID;
    END IF;
  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_obu_firmware_trg() FROM PUBLIC;

CREATE TRIGGER obu_firmware_trg
	BEFORE INSERT ON obu_firmware FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_obu_firmware_trg();

DROP TRIGGER IF EXISTS rw_buffer_action_lut_trigger ON rw_buffer_action_lut CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_rw_buffer_action_lut_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('rw_buffer_action_lut_seq')
  INTO STRICT   NEW.rw_buffer_action_lut_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_rw_buffer_action_lut_trigger() FROM PUBLIC;

CREATE TRIGGER rw_buffer_action_lut_trigger
	BEFORE INSERT ON rw_buffer_action_lut FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_rw_buffer_action_lut_trigger();

DROP TRIGGER IF EXISTS sec_result_code_type_trigger ON security_result_code_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_sec_result_code_type_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('security_result_code_type_seq')
  INTO STRICT   NEW.security_result_code_type_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_sec_result_code_type_trigger() FROM PUBLIC;

CREATE TRIGGER sec_result_code_type_trigger
	BEFORE INSERT ON security_result_code_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_sec_result_code_type_trigger();

DROP TRIGGER IF EXISTS tim_trigger_ ON tim CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_tim_trigger_() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('tim_seq')
  INTO STRICT   NEW.tim_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_tim_trigger_() FROM PUBLIC;

CREATE TRIGGER tim_trigger_
	BEFORE INSERT ON tim FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_tim_trigger_();

DROP TRIGGER IF EXISTS tim_type_trigger ON tim_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_tim_type_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('tim_type_seq')
  INTO STRICT   NEW.tim_type_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_tim_type_trigger() FROM PUBLIC;

CREATE TRIGGER tim_type_trigger
	BEFORE INSERT ON tim_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_tim_type_trigger();

DROP TRIGGER IF EXISTS tokens_trg ON tokens CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_tokens_trg() RETURNS trigger AS $BODY$
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF TG_OP = 'INSERT' AND NEW.ID IS NULL THEN
      SELECT nextval('tokens_seq') INTO STRICT NEW.ID;
    END IF;
  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_tokens_trg() FROM PUBLIC;

CREATE TRIGGER tokens_trg
	BEFORE INSERT ON tokens FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_tokens_trg();

DROP TRIGGER IF EXISTS trac_message_sent_trigger ON trac_message_sent CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trac_message_sent_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('trac_message_sent_seq')
  INTO STRICT   NEW.trac_message_sent_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trac_message_sent_trigger() FROM PUBLIC;

CREATE TRIGGER trac_message_sent_trigger
	BEFORE INSERT ON trac_message_sent FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trac_message_sent_trigger();

DROP TRIGGER IF EXISTS trac_message_type_trigger ON trac_message_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trac_message_type_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('trac_message_type_seq')
  INTO STRICT   NEW.trac_message_type_id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trac_message_type_trigger() FROM PUBLIC;

CREATE TRIGGER trac_message_type_trigger
	BEFORE INSERT ON trac_message_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trac_message_type_trigger();

-- DROP TRIGGER IF EXISTS trg_bsm_core_data_id ON bsm_core_data CASCADE; -- SKIPPING BSM-RELATED TRIGGERS
-- CREATE OR REPLACE FUNCTION trigger_fct_trg_bsm_core_data_id() RETURNS trigger AS $BODY$
-- BEGIN
-- select nextval('bsm_core_data_id_seq')
-- into STRICT NEW.bsm_core_data_id
-- ;
-- RETURN NEW;
-- end
-- $BODY$
--  LANGUAGE 'plpgsql' SECURITY DEFINER;
-- -- REVOKE ALL ON FUNCTION trigger_fct_trg_bsm_core_data_id() FROM PUBLIC;

-- CREATE TRIGGER trg_bsm_core_data_id -- SKIPPING BSM-RELATED TRIGGERS
-- 	BEFORE INSERT ON bsm_core_data FOR EACH ROW
-- 	EXECUTE PROCEDURE trigger_fct_trg_bsm_core_data_id();

-- DROP TRIGGER IF EXISTS trg_bsm_part2_suve_id ON bsm_part2_suve CASCADE;
-- CREATE OR REPLACE FUNCTION trigger_fct_trg_bsm_part2_suve_id() RETURNS trigger AS $BODY$
-- BEGIN
-- select nextval('bsm_part2_suve_id_seq')
-- into STRICT NEW.bsm_part2_suve_id
-- ;
-- RETURN NEW;
-- end
-- $BODY$
--  LANGUAGE 'plpgsql' SECURITY DEFINER;
-- -- REVOKE ALL ON FUNCTION trigger_fct_trg_bsm_part2_suve_id() FROM PUBLIC;

-- CREATE TRIGGER trg_bsm_part2_suve_id -- SKIPPING BSM-RELATED TRIGGERS
-- 	BEFORE INSERT ON bsm_part2_suve FOR EACH ROW
-- 	EXECUTE PROCEDURE trigger_fct_trg_bsm_part2_suve_id();

-- DROP TRIGGER IF EXISTS trg_bsm_part2_vse_id ON bsm_part2_vse CASCADE;
-- CREATE OR REPLACE FUNCTION trigger_fct_trg_bsm_part2_vse_id() RETURNS trigger AS $BODY$
-- BEGIN
-- select nextval('bsm_part2_vse_seq')
-- into STRICT NEW.bsm_part2_vse_id
-- ;
-- RETURN NEW;
-- end
-- $BODY$
--  LANGUAGE 'plpgsql' SECURITY DEFINER;
-- -- REVOKE ALL ON FUNCTION trigger_fct_trg_bsm_part2_vse_id() FROM PUBLIC;

-- CREATE TRIGGER trg_bsm_part2_vse_id -- SKIPPING BSM-RELATED TRIGGERS
-- 	BEFORE INSERT ON bsm_part2_vse FOR EACH ROW
-- 	EXECUTE PROCEDURE trigger_fct_trg_bsm_part2_vse_id();

DROP TRIGGER IF EXISTS trg_category_id ON category CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_category_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('category_id_seq')
into STRICT NEW.category_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_category_id() FROM PUBLIC;

CREATE TRIGGER trg_category_id
	BEFORE INSERT ON category FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_category_id();

DROP TRIGGER IF EXISTS trg_computed_lane_id ON computed_lane CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_computed_lane_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('computed_lane_id_seq')
into STRICT NEW.computed_lane_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_computed_lane_id() FROM PUBLIC;

CREATE TRIGGER trg_computed_lane_id
	BEFORE INSERT ON computed_lane FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_computed_lane_id();

DROP TRIGGER IF EXISTS trg_data_frame_id ON data_frame CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_data_frame_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('data_frame_seq')
into STRICT NEW.data_frame_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_data_frame_id() FROM PUBLIC;

CREATE TRIGGER trg_data_frame_id
	BEFORE INSERT ON data_frame FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_data_frame_id();

DROP TRIGGER IF EXISTS trg_data_frame_itis_code_id ON data_frame_itis_code CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_data_frame_itis_code_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('data_frame_itis_code_id_seq')
into STRICT NEW.data_frame_itis_code_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_data_frame_itis_code_id() FROM PUBLIC;

CREATE TRIGGER trg_data_frame_itis_code_id
	BEFORE INSERT ON data_frame_itis_code FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_data_frame_itis_code_id();

DROP TRIGGER IF EXISTS trg_data_list_id ON data_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_data_list_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('data_list_id_seq')
into STRICT NEW.data_list_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_data_list_id() FROM PUBLIC;

CREATE TRIGGER trg_data_list_id
	BEFORE INSERT ON data_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_data_list_id();

DROP TRIGGER IF EXISTS trg_disabled_list_id ON disabled_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_disabled_list_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('disabled_list_id_seq')
into STRICT NEW.disabled_list_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_disabled_list_id() FROM PUBLIC;

CREATE TRIGGER trg_disabled_list_id
	BEFORE INSERT ON disabled_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_disabled_list_id();

DROP TRIGGER IF EXISTS trg_enabled_list_id ON enabled_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_enabled_list_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('enabled_list_id_seq')
into STRICT NEW.enabled_list_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_enabled_list_id() FROM PUBLIC;

CREATE TRIGGER trg_enabled_list_id
	BEFORE INSERT ON enabled_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_enabled_list_id();

DROP TRIGGER IF EXISTS trg_http_logging_id ON http_logging CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_http_logging_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('http_logging_seq')
into STRICT NEW.http_logging_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_http_logging_id() FROM PUBLIC;

CREATE TRIGGER trg_http_logging_id
	BEFORE INSERT ON http_logging FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_http_logging_id();

DROP TRIGGER IF EXISTS trg_itis_code_id ON itis_code CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_itis_code_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('itis_code_id_seq')
into STRICT NEW.itis_code_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_itis_code_id() FROM PUBLIC;

CREATE TRIGGER trg_itis_code_id
	BEFORE INSERT ON itis_code FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_itis_code_id();

DROP TRIGGER IF EXISTS trg_local_node_id ON local_node CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_local_node_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('local_node_id_seq')
into STRICT NEW.local_node_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_local_node_id() FROM PUBLIC;

CREATE TRIGGER trg_local_node_id
	BEFORE INSERT ON local_node FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_local_node_id();

DROP TRIGGER IF EXISTS trg_node_ll_id ON node_ll CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_node_ll_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('node_ll_id_seq')
into STRICT NEW.node_ll_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_node_ll_id() FROM PUBLIC;

CREATE TRIGGER trg_node_ll_id
	BEFORE INSERT ON node_ll FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_node_ll_id();

DROP TRIGGER IF EXISTS trg_node_xy_id ON node_xy CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_node_xy_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('node_xy_id_seq')
into STRICT NEW.node_xy_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_node_xy_id() FROM PUBLIC;

CREATE TRIGGER trg_node_xy_id
	BEFORE INSERT ON node_xy FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_node_xy_id();

DROP TRIGGER IF EXISTS trg_old_region_id ON old_region CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_old_region_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('old_region_id_seq')
into STRICT NEW.old_region_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_old_region_id() FROM PUBLIC;

CREATE TRIGGER trg_old_region_id
	BEFORE INSERT ON old_region FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_old_region_id();

DROP TRIGGER IF EXISTS trg_path_id ON path CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_path_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('path_id_seq')
into STRICT NEW.path_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_path_id() FROM PUBLIC;

CREATE TRIGGER trg_path_id
	BEFORE INSERT ON path FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_path_id();

DROP TRIGGER IF EXISTS trg_path_node_ll_id ON path_node_ll CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_path_node_ll_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('path_node_ll_seq')
into STRICT NEW.path_node_ll_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_path_node_ll_id() FROM PUBLIC;

CREATE TRIGGER trg_path_node_ll_id
	BEFORE INSERT ON path_node_ll FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_path_node_ll_id();

DROP TRIGGER IF EXISTS trg_path_node_xy_id ON path_node_xy CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_path_node_xy_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('path_node_xy_seq')
into STRICT NEW.path_node_xy_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_path_node_xy_id() FROM PUBLIC;

CREATE TRIGGER trg_path_node_xy_id
	BEFORE INSERT ON path_node_xy FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_path_node_xy_id();

DROP TRIGGER IF EXISTS trg_region_id ON region CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_region_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('region_id_seq')
into STRICT NEW.region_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_region_id() FROM PUBLIC;

CREATE TRIGGER trg_region_id
	BEFORE INSERT ON region FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_region_id();

DROP TRIGGER IF EXISTS trg_region_list_id ON region_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_region_list_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('region_list_id_seq')
into STRICT NEW.region_list_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_region_list_id() FROM PUBLIC;

CREATE TRIGGER trg_region_list_id
	BEFORE INSERT ON region_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_region_list_id();

DROP TRIGGER IF EXISTS trg_rsu_id ON rsu CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_rsu_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('rsu_id_seq')
into STRICT NEW.rsu_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_rsu_id() FROM PUBLIC;

CREATE TRIGGER trg_rsu_id
	BEFORE INSERT ON rsu FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_rsu_id();

DROP TRIGGER IF EXISTS trg_shape_point_id ON shape_point CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_shape_point_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('shape_point_id_seq')
into STRICT NEW.shape_point_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_shape_point_id() FROM PUBLIC;

CREATE TRIGGER trg_shape_point_id
	BEFORE INSERT ON shape_point FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_shape_point_id();

DROP TRIGGER IF EXISTS trg_shape_point_node_xy_id ON shape_point_node_xy CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_shape_point_node_xy_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('shape_point_node_xy_id_seq')
into STRICT NEW.shape_point_node_xy_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_shape_point_node_xy_id() FROM PUBLIC;

CREATE TRIGGER trg_shape_point_node_xy_id
	BEFORE INSERT ON shape_point_node_xy FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_shape_point_node_xy_id();

DROP TRIGGER IF EXISTS trg_speed_limits_id ON speed_limits CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_speed_limits_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('speed_limits_id_seq')
into STRICT NEW.speed_limits_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_speed_limits_id() FROM PUBLIC;

CREATE TRIGGER trg_speed_limits_id
	BEFORE INSERT ON speed_limits FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_speed_limits_id();

DROP TRIGGER IF EXISTS trg_status_log_id ON status_log CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_status_log_id() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('status_log_id_seq')
  INTO STRICT NEW.LOG_ID
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_status_log_id() FROM PUBLIC;

CREATE TRIGGER trg_status_log_id
	BEFORE INSERT ON status_log FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_status_log_id();

DROP TRIGGER IF EXISTS trg_tim_rsu_id ON tim_rsu CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_tim_rsu_id() RETURNS trigger AS $BODY$
BEGIN
select nextval('tim_rsu_id_seq')
into STRICT NEW.tim_rsu_id
;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_tim_rsu_id() FROM PUBLIC;

CREATE TRIGGER trg_tim_rsu_id
	BEFORE INSERT ON tim_rsu FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_tim_rsu_id();

